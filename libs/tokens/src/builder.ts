import StyleDictionary from 'style-dictionary';
import { promises as fs } from 'fs';

/**
 * ConfiguraciÃ³n de marcas y temas
 */
const BRANDS = [
  'white-label',
  'jelpit',
  'davivienda',
  'cien-cuadras',
  'doctor-aki',
  'seguros-bolivar'
];

const THEMES = ['light', 'dark'];

/**
 * Formato personalizado para CSS Variables optimizado
 * Genera variables SIN el prefijo de la marca para que sean estÃ¡ndares
 */
StyleDictionary.registerFormat({
  name: 'css/variables-custom',
  format: ({ dictionary, options }) => {
    const { brand = 'default', theme = 'light' } = options;
    const selector = `[data-brand="${brand}"][data-theme="${theme}"]`;
    
    const tokens = dictionary.allTokens
      .map(token => {
        // Remover el nombre de la marca del path para tener nombres estÃ¡ndar
        const cleanPath = token.path.filter(part => 
          part !== brand && 
          part !== 'primitive' &&
          part !== '$value'
        );
        const name = cleanPath.join('-');
        const value = token.$value || token.value;
        return `  --${name}: ${value};`;
      })
      .join('\n');

    return `/**
 * Design Tokens - ${brand} ${theme}
 * Generated by Style Dictionary
 * DO NOT EDIT DIRECTLY
 * 
 * Variables estÃ¡ndar (sin prefijo de marca)
 * Ejemplo: --color-primary-base (no --jelpit-color-primary-base)
 */

${selector} {
${tokens}
}
`;
  }
});

/**
 * Filtro para excluir tokens primitivos en el output final
 */
StyleDictionary.registerFilter({
  name: 'filter-primitives',
  filter: (token) => !token.path.includes('primitive')
});

/**
 * Transform para nombres de tokens CSS
 */
StyleDictionary.registerTransform({
  name: 'name/css-custom',
  type: 'name',
  transform: (token) => {
    return token.path
      .filter(part => part !== 'primitive')
      .join('-')
      .replace(/\$/g, '');
  }
});

/**
 * Construir tokens para una marca y tema especÃ­ficos
 */
async function buildBrandTheme(brand: string, theme: string) {
  const config = {
    source: [
      `src/primitives/brands/${brand}.json`,
      `src/semantic/${theme}.json`,
      'src/components/**/*.json'
    ],
    platforms: {
      css: {
        transformGroup: 'css',
        transforms: ['name/css-custom', 'color/css'],
        buildPath: 'dist/',
        files: [
          {
            destination: `${brand}-${theme}.css`,
            format: 'css/variables-custom',
            options: {
              brand,
              theme
            }
          }
        ]
      }
    }
  };

  const sd = new StyleDictionary(config);
  await sd.buildAllPlatforms();
  console.log(`âœ… Built: ${brand}-${theme}.css`);
}

/**
 * Generar TypeScript types para tokens
 */
async function generateTypes() {
  const typesContent = `/**
 * Design Tokens Types
 * Auto-generated from Style Dictionary
 */

export type Brand = ${BRANDS.map(b => `'${b}'`).join(' | ')};
export type Theme = ${THEMES.map(t => `'${t}'`).join(' | ')};

export interface TokenConfig {
  brand: Brand;
  theme: Theme;
}

/**
 * Get CSS file path for a brand/theme combination
 */
export function getTokensPath(config: TokenConfig): string {
  return \`@root-block/tokens/\${config.brand}-\${config.theme}.css\`;
}

/**
 * Available brand/theme combinations
 */
export const AVAILABLE_CONFIGS: TokenConfig[] = [
${BRANDS.flatMap(brand => 
  THEMES.map(theme => `  { brand: '${brand}', theme: '${theme}' }`)
).join(',\n')}
];
`;

  await fs.writeFile('dist/index.d.ts', typesContent);
  console.log('âœ… Generated TypeScript types');
}

/**
 * Generar archivo index.js para importaciones
 */
async function generateIndex() {
  const indexContent = `/**
 * Root Block Design Tokens
 * @root-block/tokens
 */

export const BRANDS = ${JSON.stringify(BRANDS, null, 2)};
export const THEMES = ${JSON.stringify(THEMES, null, 2)};

export function getTokensPath(brand, theme) {
  return \`@root-block/tokens/\${brand}-\${theme}.css\`;
}

export const AVAILABLE_CONFIGS = ${JSON.stringify(
  BRANDS.flatMap(brand => THEMES.map(theme => ({ brand, theme }))),
  null,
  2
)};
`;

  await fs.writeFile('dist/index.js', indexContent);
  console.log('âœ… Generated index.js');
}

/**
 * Main build process
 */
async function build() {
  console.log('ğŸš€ Building Root Block Design Tokens...\n');

  // Crear directorio dist si no existe
  await fs.mkdir('dist', { recursive: true });

  // Build para cada combinaciÃ³n de marca/tema
  for (const brand of BRANDS) {
    for (const theme of THEMES) {
      await buildBrandTheme(brand, theme);
    }
  }

  // Generar tipos y archivos auxiliares
  await generateTypes();
  await generateIndex();

  console.log('\nâœ¨ Build completed successfully!');
  console.log(`\nğŸ“¦ Generated ${BRANDS.length * THEMES.length} CSS files in dist/`);
}

// Ejecutar build
build().catch(error => {
  console.error('âŒ Build failed:', error);
  process.exit(1);
});

